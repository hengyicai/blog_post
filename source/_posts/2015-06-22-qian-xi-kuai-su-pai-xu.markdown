---
layout: post
title:  "浅析快速排序"
date: 2015-06-22 11:17:54 +0800
comments: true
categories: 算法相关
tags: [快速排序, 二叉搜索树, 数据结构]
keywords: 快速排序, 二叉搜索树, 数据结构
description: 快速排序的简单分析
---

## 概述

快速排序是比较简单的一种排序方法，是一种分治算法，有较高的性能，对于n个元素而言，绝大多数情况下算法的运行时间为$O(N\log{N})$,最坏情况下，运行时间为$O(n^{2})$，比如说待排序的数组已经有序，无论是升序还是降序。

快速排序和归并排序有可以比较的地方，归并排序中，重点在于**并**，而快速排序中，重点在于**分**的过程，大致思路是这样的


## 具体过程

首先拿出数组中的一个元素作为标杆，以此标杆作为参照，将比这个标杆小的元素扔到它的左边，将比这个标杆大的扔到它的右边；然后递归地在左半部分（均比标杆值小）和右半部分（均比标杆值大）进行这个过程，最终数组就排好序了。

显然，思路是很简单的，并且，这个排序过程是**原地排序**，不像归并排序还需要额外的空间，所以快速排序更加节省内存使用。

快排的过程就如下面这几行代码一样

```C
void QuickSort( int *arr,int p,int r)
{
	if(p < r)
	{
		//将数组arr中从p到r的元素，以p为标杆值
		//进行切分，并返回最终标杆值的位置q
		int q = Partition(arr,p,r);
		//递归对左半部分进行排序
		QuickSort(arr,p,q);
		//递归对右半部分进行排序
		QuickSort(arr,q+1,r);
	}
}
```

所以关键的地方在于`Partition()`这个函数，就是如何对数组进行切分，这个过程也是快排的核心，我们先搞清楚这个过程要干嘛，很明显，这个过程的初始状态是一个数组，里面的元素随机排列，而结束状态是标杆值在中间，标杆值左边的数都比标杆小，右边的数都比它大（也可能某一边是空集）。那么按照下面这个过程，便可以使得数组从初始状态变到指定的结束状态。

 - 选取数组的第一个元素为标杆（可以任意选择，为了方便，这里选择第一个）
 - 令$i$指向数组的第一个元素，$j$指向数组的第二个元素
 - $j$开始从第二个位置一直遍历到最后一个位置，在每一次遍历的时候，如果$j$处的元素值大于标杆值，$j$++，否则，$i$+=1，并且将i处的元素和$j$处的元素交换位置，然后$j$++
 - 最后，将数组第一个位置的元素（标杆）和$i$处的元素交换位置。

这个过程便是快排中划分数组的标准化过程，实现如下

```C
int Partition(int *arr,int p,int r)
{
	//设置标杆为数组的第一个元素
	int x = arr[p];
	//索引i的初始值
	int i = p;
	int j;
	for(j = i+1;j<r;j++)
	{
		if(arr[j]<=x)
		{
			Exchange(arr,++i,j);
		}
	}
	Exchange(arr,i,p);
	return i;
}
```

## 简要分析

整个过程便是这样，想一下整个过程，第一次对整个数组做划分，然后分别对数组的一半做划分，再减半，再减半，最终整个数组便有序了，可以证明，只要每次划分不出现空集，即标杆元素的两边只要有值，不管两边的元素数目比例怎样（比如划分完标杆两边的元素数目是$1000:1$），算法的性能总是在$O(N\log{N})$，具体证明参见《算法导论》。

快排其实和二叉搜索树很有联系，想象一下，每次选出的标杆其实就是树的根节点，标杆的左边的所有元素均小于标杆值，标杆的右边的所有元素均大于标杆值(假定所有元素互异)，这种特性正好对应于二叉搜索树的特点：左子树的元素小于根节点，右子树的元素大于根节点。而快速排序的过程其实就是以中序遍历的顺序构造二叉搜索树的过程。

  



