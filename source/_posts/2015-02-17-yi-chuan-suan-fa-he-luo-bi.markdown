---
layout: post
title:  "遗传算法和罗比"
date: 2015-02-17 20:21:01 +0800
comments: true
categories: 算法相关
tags: [GA, 遗传算法, 罗比]
keywords: GA, 遗传算法, 罗比, 进化
description: 遗传算法寻找最佳策略
---

前段时间，看到一本书上讲到用遗传算法寻找最佳游戏策略的部分，受其启发，自己实现了一个，总结在此。

##	问题背景
关于遗传算法的google上很多很好的介绍，下面主要介绍一下我编写程序解决的这个问题。我现在有一个叫做罗比的机器人，它的世界是二维的，你可以把它的世界想象成一个**M乘以N**的网格，它的世界里到处是废易拉罐，这些废易拉罐的分布完全是随机的，我现在要为它寻求一个策略，让它去清扫这些易拉罐，而且是**快速有效**地清理，他毕竟没有脑袋。

{% img center /images/c55d5d7egw1epcn7bkjcrj20lr0ihads.jpg %}

上图是罗比世界的示意图，图中散乱放着易拉罐，当然，只是示意图，**M** 和 **N** 可以随意指定。我们假设它的世界周围是高高的墙，每个格子里面的易拉罐不多于**１**个，罗比本身并不是很聪明，也看不远，它只能看到自己当前所在的格子和它周围的四个格子，显然，每个格子有三种状态：空的，有一个易拉罐，墙壁。比如罗比现在看到它的东边有易拉罐，北边和西边是墙，南边的格子是空的。

每次罗比的动作我们规定有以下几种

```
    向北移动
	向东移动
	向南移动
	向西移动
	随机移动
	不动
	收集罐子
```

我为它设计了如下的计分规则

```
	如果当前格子中有罐子而且清理了，加 10 分。
	如果当前格子中没有罐子却执行清理的动作，扣 1 分。
	如果撞到了墙，扣 5 分，并且弹回原来的格子。
```

当然，罗比尽可能多捡罐子，不要撞墙，没罐子的时候别去捡，得到的分数就会越多。这个问题比较简单，用确定性算法设计一个好策略也不是难事，不过我比较懒，我下面用 **遗传算法** 为他进化出一个好策略。

##	策略是什么
我们先要搞清楚我们要进化什么，也就是我们要定义清楚我们的策略，在这里，我定义罗比的策略是 K-V 形式的映射关系，其中的键是罗比当前的情况，值是罗比应该执行的动作，我们把每个格子的三种状态映射到整数:

```
 空 --> 0
 有罐子 --> 1
 墙壁 --> 2
```

把罗比可以执行的动作也映射到整数:

```
	向北移动 --> 0
	向东移动 --> 1
	向南移动 --> 2
	向西移动 --> 3
	随机移动 --> 4
	不动 --> 5
	收集罐子 --> 6
```

给定顺序：**[北，东，南，西，中]**，那么罗比在最开始那副图中的"情况"就是 **[ 2 , 1 , 0 , 2 , 0 ]** ,很显然，现在它应该向东移动，那么这个键对应的值就是 1，包括自己当前的格子共五个方向，每个方向又有三种可能的状态，那么，情况一共就有 $3\times3\times3\times3\times3＝243$ 种，当然一些情况是不可能的，比如罗比当前的位置是墙，不过我很懒，不想费劲找出所有不可能的情况，我们只要知道就行了。那么现在有 243 个键值对，这个 --键值表(策略表)-- 就是我们的策略，应该说是罗比的策略，每次罗比只要抬头四周望望，然后根据自己当前的情况到策略表中找对应的动作，然后执行，下一次再这样，它就可以根据这个策略来清理罐子了。我们还可以把键的顺序按照一定的原则固定下来，那么只要有一个值的列表就可以了，罗比会知道当前的情况是情况几，然后直接查对应的值去执行动作就行，这样一来，罗比的策略就是 **一个有243个元素的一维数组**，比如说下面的这个是它的一个策略:


**[2,5,0,4,2,1,3,2,4,1,2,3,2,4,1,2,3,2,1,2,1,2,1,2,1,2,4,2,2,2,4,...,3,5,6,0]**



可是这样的策略有多少种呢？一共有 **$7^{243}$** 种，是个很大的数字，**注意**，这么多策略中可能 **90%** 以上都是糟糕的策略，比如说罗比现在的北边是墙壁，策略表中对应的动作却是向北移动，那好，罗比会一头撞在墙上，所以我们的目的是为罗比找出最优的策略，让它的得分尽可能地多。

## 求解
还是简要地介绍一下遗传算法，遗传算法是一种最优化的算法，在数模界广为流传的几种智能优化算法，遗传算法是其中一种，其他还有模拟退火算法，蚁群算法等，不要被它的 **智能** 吓唬到，它的原理不是异常复杂，但是遗传算法却有很多可以拓展的地方，它的应用也很广泛，德州仪器(Texas Instruments)将它用于生产计算机芯片，2003年的电影《指环王》也用它来生成逼真的动画马匹，还有很多应用，引用维基百科的话:

**遗传算法是模仿自然界生物进化机制发展起来的随机全局搜索和优化方法，它借鉴了达尔文的进化论和孟德尔的遗传学说。其本质是一种高效、并行、全局搜索的方法，它能在搜索过程中自动获取和积累有关搜索空间的知识，并自适应的控制搜索过程以求得最优解。遗传算法操作使用适者生存的原则，在潜在的解决方案种群中逐次产生一个近似最优解的方案，在遗传算法的每一代中，根据个体在问题域中的适应度值和从自然遗传学中借鉴来的再造方法进行个体选择，产生一个新的近似解。这个过程导致种群中个体的进化，得到的新个体比原来个体更能适应环境，就像自然界中的改造一样。
遗传算法是计算机科学人工智能领域中用于解决最优化的一种搜索启发式算法，是进化算法的一种。这种启发式通常用来生成有用的解决方案来优化和搜索问题。进化算法最初是借鉴了进化生物学中的一些现象而发展起来的，这些现象包括遗传、突变、自然选择以及杂交等。**

其中有几个关键词：**个体，种群，适应度，自然选择，杂交，突变，编码**，在我们这个问题的求解中，这些关键词会一一讲到。

最开始，我用**matlab**来编写程序求解这个问题，但是运行的效率实在太慢了，于是我用C语言重新实现了一下，我先说结果吧，如果这个网格的大小是**30$\times$30**，其中易拉罐的比例设在**0.5**,每次游戏我让罗比行动**200**步，那么，这个游戏的满分就是**2000**分，我自己事先按照我觉得比较好的策略给罗比用，就是向有罐子的地方移动，有罐子就捡起来，不要撞墙，罗比按照这个策略清理**1000**次，每次罐子的分布都随机，平均得分是**1210**分，猜猜遗传算法进化出来的策略平均得分是多少？**1992分！**,几乎是满分了，下面我们看这个算法是如何做到的，只列部分的代码，完整的代码在[这里](https://github.com/hengyicai/roby "完整代码")下载。

###算法概要
首先讲一下大致的思路，其实为罗比寻找最佳策略的过程就是一个进化的过程，你可以想象有一个种群，这个种群中有若干个个体，每个个体代表一个策略，其实前面我们说每个策略表示为一个长度为 **243** 的数组，这个就是编码的过程，不同的问题有不同的编码方式，比较多的是二进制编码，不过我们这里更加适合字符串编码方式，编码完成之后， 我们让这个种群按照**适者生存，物竞天择**的原则进行进化，最后进化到一定的代数之后，剩下来的就是那些比较优秀的个体，也就是那些比较好的策略，从最后一代中选出一个最好的个体，OK ,这个就是我们为罗比找到的好策略。


主函数中关键的就三行，选择，重组，变异

```C
void main()
{
	//随机生成解
	int solu[POP_SIZE][SOLU_DIM];
	init_solu(solu);
	
	int i;
	double fit[POP_SIZE];
	
	//最初的解
	get_fitness(solu,fit);
	printf("当前的最高分数为:%f  ",max(fit,POP_SIZE));

	printf("\n计算中........\n");

	//进化
	for(i = 0; i < GEN_NUM;i++)
	{
		ga_sel(solu);  //选择
		ga_cross(solu);  //交叉重组
		ga_mut(solu);  //变异
	}

	//进化完毕，输出最终的解
	get_fitness(solu,fit);
	printf("最终的最高分数为:%f  ",max(fit,POP_SIZE));	
	printf("\n");
}
```

这里面有几个关键的地方

 1.   每个个体怎么表示？
 2.   如何度量一个个体的优劣程度？
 3.   种群如何不断**选择**，**重组**，**变异**?


####问题一：个体和种群的表示
对于第一个问题，其实对应于遗传算法中的编码过程，也就是将现实问题的解对应到程序中的具体表示，上文中说道我们可以把罗比所能碰到的所有情形和该情形下执行的动作当成一个键值表，那么在这里**现实问题的解**就是这张键值表中的某一个键值对，而这个键值对在程序中我们可以很方便的表示，为了更方便一些，我们把键出现的顺序固定下来，那么只要用一个长度为**243**的一维数组就可以表示了，索引表示情形(可以把每种情形映射到一个**0到242**的整数，下文会讲到)，数组的值表示该情形下罗比该执行的动作(前文中已经编号)，于是我们就可以用一个一维数组表示一个解，也就是一张策略表，即一个个体，假定种群包含**200**个个体，我们设定种群的大小为 200 ，那么这个种群就可以用一个 $200\times243$ 的矩阵来表示，就像下面这样：

$$\begin{bmatrix}2&0&3&4&0&6&5&2&1&4&...&5&4&0&6\\\\
4&5&6&0&5&3&4&1&2&6&...&0&1&2&4\\\\
&&&&&&&...\\\\
&&&&&&&...\\\\
&&&&&&&...\\\\
5&2&1&4&2&1&5&4&3&4&...&4&1&2&3\\\\
1&4&2&3&4&5&4&4&2&0&...&0&1&2&4\end{bmatrix}$$

其中，每一行表示一个个体，所以这个矩阵表示的是一个有 200 个个体的种群。

下面说一下某一种情形如何映射到一个**0~242**的整数。

罗比所面对的某一种情形类似下面的形式


-  北 --> 墙壁(2)
-  东 --> 易拉罐(1)
-  南 --> 空(0)
-  西 --> 墙壁(2)
-  中 --> 空(0)


第一列是方位，第二列是此处的状态，这种情形对应的表示就是**21020**，我们可以把这个数字当做**三进制**的数，因为每一位都有三种取值，这种情形对应的十进制值就是:

$$2\times3{^4} + 1\times3{^3} + 0\times3{^2} + 2\times3{^1} + 0\times3{^0} = 195$$

按照这种编码方式，第**1**种情形到第**243**种情形都可以用一个**0到242**之间的整数表示，而且顺序是唯一的，那么具体情形到整数之间的映射就完成了，我们可以用这个整数值作为数组的索引，而罗比也可以根据自己面对的情形知道其所对应的编号，立刻得到对应索引位处的整数，即动作编号，然后执行相应的动作。


下面代码用来生成一个初始种群

```C
/**生成初始解**/
void init_solu(int solu[][SOLU_DIM])
{
	int i,j;
	for(i = 0;i < POP_SIZE;i++)
		for(j = 0;j < SOLU_DIM;j++)
			solu[i][j] = m_round(rand_zo()*6);
}
```


顺便说下罗比的模拟世界，我们用一个二维数组生成罗比的网格世界，然后为它建好墙壁，撒上易拉罐。

```C
void init_world(int world[][COL],double p)
{
	int i,j;

	//初始每个格子为空，用０表示
	for(i = 0;i < ROW;i++)
	    for(j = 0;j < COL;j++)
		world[i][j] = 0;

	//放置墙壁,2代表墙壁
	for(i = 0;i < ROW;i++)
	{
		world[0][i] = 2;
		world[i][0] = 2;
		world[ROW-1][i] = 2;
		world[i][COL-1] = 2;
	}

	//放置易拉罐
	for(i = 1;i < ROW - 1;i++)
	    for(j = 1;j < COL - 1;j++)
		if(rand_zo()<p)
		    world[i][j] = 1;
}
```

该函数接收一个二维数组和概率 p ,以这个概率在罗比的世界里放置易拉罐。

####问题二：度量个体的优劣程度
对于每一个个体(策略)，我们让罗比用它去清理 100 次，在每次清理过程中执行**200**次动作，每次清理都有一个得分，取这 **100** 次的平均成绩作为它的最终得分，注意，**100** 次清理，每次清理的世界都不同(每次随机放置易拉罐) , 这样，我们就大致衡量出了每个个体的好坏。
在代码中，这个评价函数接受一个种群，也就是 **200** 个个体，然后返回一个长度为 **200** 的得分数组，里面的元素对应每一个个体的分数，也叫做它的适应度，为了使适应度都为正值(因为后面要求和算比率), 我给每个个体的最终得分加上了最低得分的相反数，那么每个个体的得分区间就是 **[0,2000]**。

```C
/**适应度**/
void get_fitness(int solu[][SOLU_DIM],double fitness[])
{
	int i,j;
	
	int ST[SOLU_DIM]; //每个个体对应一张策略表

	for(i = 0; i < POP_SIZE;i++)
	{
		for(j = 0;j < SOLU_DIM;j++)
			ST[j] = solu[i][j];
		
		double per_sum = 0;
		/*对于每一个个体，给它CL_TIMES机会打扫,取平均成绩做为它的适应度分数,每一次的世界都不同，但是策略表相同*/
		for(j = 0;j < CL_TIMES;j++)
		{
			int wor[ROW][COL];
			init_world(wor,P);
			per_sum += do_clean(wor,ST);
		}

		//保证适应度是正数
		fitness[i] = per_sum/CL_TIMES + 5*PER_DO_TIMES;		
	}
}
```

这段代码中用到了一个函数**do_clean()**，这个函数用来模拟罗比清理的过程，它接收一个脏乱的世界和一个清扫策略，然后罗比按照这个清扫策略执行动作**200**次，返回这一次清扫过程的得分，下面是具体过程


```C
/**根据策略表ST,执行清扫动作,返回对应的分数**/
double do_clean(int wor[][COL],int ST[])
{
	//约定：可以执行的动作有：
	//				向北移动　０
	//				向东移动　１
	//				向南移动　２
	//				向西移动　３
	//				随机移动　４
	//				　不动　　５
	//				清理罐子　６
	//计分规则：
	//	如果罗比所在的格子中有罐子，并且打扫了罐子，+10分
	//	如果执行打扫的动作而当前格子中没有罐子, -1分
	//	如果撞到了墙，-5分，并且弹回原来的格子
	
	//从左上角开始打扫
	int pos[2] = {1,1};
	double sc = 0;
	int i; 
	
	for(i = 0; i < PER_DO_TIMES;i++)
	{
		// 得到当前位置的情况
		int situ[5];
		situ[0] = wor[pos[0] - 1][pos[1]];
		situ[1] = wor[pos[0]][pos[1] + 1];
		situ[2] = wor[pos[0] + 1][pos[1]];
		situ[3] = wor[pos[0]][pos[1] - 1];
		situ[4] = wor[pos[0]][pos[1]];

		// 得到此情况下的策略编号
		int str_num = get_stra(situ);

		// 按照此策略进行行动，并对wor和sc进行对应更新
		int dire;
		int rand_num;
		switch(ST[str_num])
		{
			case 0:
				//向北移动
N:
				if(move(pos[0],pos[1],0))
					sc -= 5;
				else
					pos[0]--;
				break;
			case 1:
				//向东移动
E:
				if(move(pos[0],pos[1],1))
					sc -= 5;
				else
					pos[1]++;
				break;
			case 2:
				//向南移动
S:
				if(move(pos[0],pos[1],2))
					sc -= 5;
				else
					pos[0]++;
				break;
			case 3:
				//向西移动
W:
				if(move(pos[0],pos[1],3))
					sc -= 5;
				else
					pos[1]--;
				break;
			case 4:
				//随机移动
				rand_num = rand_zo();
				if(rand_num < 0.25)
					goto N;
				else if(rand_num < 0.50)
					goto E;
				else if(rand_num < 0.75)
					goto S;
				else
					goto W;
				break;
			case 5:
				//不动
				break;
			case 6:
				//清理罐子
				if(wor[pos[0]][pos[1]] == 1)
					sc += 10;
				else
					sc -= 1;
				break;
		}
	}
	return sc;
}
```

####问题三：进化过程
现在到了最有趣的地方，就是种群如何进行**选择**,**重组**,**变异**，我们一个一个来说。

**选择**

选择，顾名思义，就是从种群中选择一批比较优良的个体，让它进行繁殖，而优良的定义自然就是这个策略的得分高低，这里我们使用比较简单的轮盘赌的方式来选择个体，想象有下面这个轮盘

{% img center /images/22235409-79c6140e139549c8a74f42b9f133e917.jpg %}

每个部分的面积不同，如果有一根旋转轮盘，当然指针落在面积大的那一块上的概率会大些，注意，这里是 **概率**，具有更高适应度的个体仅仅是有比较大的概率被选中，这就保证了算法具有一定的随机性，一定程度上避免落入局部最优解，因为那些适应度不高的个体也有机会被选中，而你不能说这些适应度不高的个体就没有好的基因片段遗传给下一代，但是从总体上来讲，适应度高的个体更多的机会把自己的基因遗传给下一代。在代码中，我们先计算出每个个体的被选概率，概率之和是**1**,然后计算累计概率，进行选择，关于为什么计算累计概率，这仅仅是种实现上的技巧，只要能够按照轮盘赌的原则进行选择就可以了，选择的结果是一个新的种群，新的种群的大小和原来的种群大小是相同的，但是已经发生了变化，因为一些适应度高的个体可能被多次选中，有一些适应度很低的个体可能一次都没有被选中，也就是被淘汰了，下面是选择的具体过程

```C

//选择算子
void ga_sel(int old_pop[][SOLU_DIM])
{
	int new_pop[POP_SIZE][SOLU_DIM];
	double pr[POP_SIZE],cum_pr[POP_SIZE];
	double pr_sum = 0;
	int i,j,k;
	
	//计算每个个体的适应度
	get_fitness(old_pop,pr);

	//计算累计概率
	for(i = 0;i < POP_SIZE;i++)
		pr_sum += pr[i];
	for(i = 0;i < POP_SIZE;i++)
		pr[i] = pr[i]/pr_sum;
	cum_pr[0] = pr[0];
	for(i = 1;i < POP_SIZE;i++)
		cum_pr[i] = cum_pr[i - 1] + pr[i];

	//轮盘赌方法选择
	for(i = 0;i < POP_SIZE;i++)
	{
		double rand_n = rand_zo();
		for(j = 0; j < POP_SIZE - 1;j++)
		{
			if(rand_n < cum_pr[0])
			{
				for(k = 0;k < SOLU_DIM;k++)
					new_pop[i][k] = old_pop[0][k];
				break;
			}else if(rand_n >= cum_pr[j] && rand_n <= cum_pr[j+1])
			{
				for(k = 0;k < SOLU_DIM;k++)
					new_pop[i][k] = old_pop[j+1][k];
				break;
			}
		}
	}
	for(i = 0;i < POP_SIZE;i++)
		for(j = 0;j < SOLU_DIM;j++)
			old_pop[i][j] = new_pop[i][j];
}
```

**重组(交叉)**

现在我们进入基因重组这个步骤，基因重组的概念不用多说，我们把上一步骤中选择出来的个体，以一定的概率**P_CROSS**进行基因重组，提一句，这个程序的有很多参数，比如说种群大小，度量适应度时罗比清理的次数，每次清理中执行的动作次数，基因重组的概率，基因变异的概率，进化的代数，网格世界的大小，这些参数我都以宏的方式定义在了文件中，而这些参数是可以适当调节的，对最优解的收敛速度和收敛值会有影响，但是大体上是相似的，其实我随便设的这些参数取值，但是结果还是很好的，接近满分，另一个很重要的问题就是这个算法是一个随机的搜索算法，也正是因为随机因素的存在，算法的执行效果也更加好，类似的算法还有模拟退火。好了，回到正题，我们先以一定的概率选择个体进行交叉运算，这里的选择就是纯粹的概率了，我设的交叉概率是**0.7**，所以不管个体的适应度高还是低，每一个个体都有**0.7**的概率可以进行交叉操作，交叉的具体方式有很多种，这里我们还是选择比较简单的单点交叉，如图所示

{% img center /images/8394323_1294826338NWUh.jpg  450 180 %}

图中是以二进制来编码的，采用单点交叉，它很好地说明了单点交叉的过程。
下面是代码中的交叉过程


```C
//交叉
void ga_cross(int new_pop[][SOLU_DIM])
{
	//选择需要交叉的个体
	int count = 0;
	int need_cr[POP_SIZE];
	int i,j;
	int temp[SOLU_DIM];

	for(i = 0;i < POP_SIZE;i++)
		if(rand_zo() < P_CROSS)
		{
			need_cr[count] = i;
			count++;
		}

	if(count % 2 != 0)
		count++;
		
	//随机决定一个不为0的交叉点
	int cr_point = 0;
	while(cr_point == 0)
		cr_point = m_round(rand_zo()*SOLU_DIM);

	

	//进行交叉
	for(i = 0;i < count;i+=2 )
		for(j = cr_point;j < SOLU_DIM;j++)
		{
			temp[j] = new_pop[need_cr[i]][j];
			new_pop[need_cr[i]][j] = new_pop[need_cr[i+1]][j];
			new_pop[need_cr[i+1]][j] = temp[j];
		}
}
```

**变异**


正如自然界中的个体一样，我们的进化过程也要考虑到变异的情况，与前面两个过程不同的是，变异的过程是针对具体的基因来将的，比如说我们的种群大小是**200**，每个个体有**243**个基因，那么这个种群的**基因**总数就是$200\times243$，每一个基因都有变异的可能性，当然这个可能性是比较小的，在这里我们给定每个基因变异的概率是**0.005**，下面是变异的具体过程


```C
/***变异**/
void ga_mut(int pop[][SOLU_DIM])
{
	int ge_sum = POP_SIZE*SOLU_DIM;
	int i,j,k;
	for(i = 0; i < ge_sum;i++)
	{
		if(rand_zo() < P_MUT)
		{
			//定位此基因所在的染色体,此处，染色体即个体，下同
			int chr_loc;
			chr_loc = i/SOLU_DIM;
			//定位此基因所在染色体上的基因位
			int gen_loc;
			gen_loc = i%SOLU_DIM;
			//进行变异
			pop[chr_loc][gen_loc] = m_round(rand_zo()*6);
		}
	}
}
```

至此，种群完成了第一次进化，**选择**，**交叉**，**变异**，我们设定让此种群进化**1000**代，最终幸存下来的个体就是我们所要找的好策略。

##进一步思考
关于这个问题，还可以定义更为复杂的游戏规则，我们要做的，只是对个体的适应度做出合理的评估，剩下的就交给遗传算法去做，它自然会为我们进化出一个较好的策略，但是类似于遗传算法这样的**软算法**，只能得到**较好的解**,很多情况下这种较好的解其实已经足够好了，就像本文中的那样。

类似文中的策略表，也就是字典，很多情况下也适用，比如说五子棋，我们同样可以为它进化出一个策略表，并且在使用的过程中不断训练，最终也可以得到一个很好的策略表。

##参考文献

[梅拉妮·米歇尔(Melanie Mitchell) 《复杂》](http://www.amazon.cn/mn/detailApp/ref=asc_df_B005G13CJO1393818/?asin=B005G13CJO&tag=douban-23&creative=2384&creativeASIN=B005G13CJO&linkCode=df0)



